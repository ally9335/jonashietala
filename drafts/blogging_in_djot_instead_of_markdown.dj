---
title: "Blogging in Djot instead of Markdown"
tags: ["Djot", "Webpage", "Rust"]
---

::: epigraph
{author="John Macfarlane"}
> What if we werenâ€™t chained to the past? What if we tried to create a light markup syntax that keeps what is good about Markdown, while revising some of the features that have led to bloat and complexity in the CommonMark spec?
:::

I recently happened to see an offhand comment on [Hacker News][] about a markup language called [Djot][].
I don't really have any large issues with the {-Markdown-} [CommonMark][] I use to generate the posts for this website, but my brain saw a chance to get sidetracked yet again, and here we are.

The creator of Djot is John MacFarlane, the same philosophy professor that also created [Pandoc][] and [CommonMark][].
These might be two of the most influential projects in the markup space, so you'd get the feeling that maybe there's something to this [Djot][] thing.

# The devil is in the details

I was going to give a few examples of what Djot looks like, but honestly, 95% of the Djot I write looks exactly like Markdown.

So what's the point?

The point is to try to take the good parts of CommonMark (the standard, unambiguous syntax specification for Markdown) and improve it in two ways:

1. Make it much easier to parse.
2. Add some more features.

I'm sympathetic to the parsing problem, as it [doesn't sound that fun][Beyond Markdown]:

> There are 17 principles governing emphasis, for example, and these rules still leave cases undecided. The rules for list items and HTML blocks are also very complex. All of these rules lead to unexpected results sometimes, and they make writing a parser for CommonMark a complex affair. I despair, at times, of getting to a spec that is worth calling 1.0.

For this alone I'd be willing to at least try Djot, but there are some added features I'd like to use.
It's true that I probably won't have much use for things like definition lists, different ordered list styles, footnotes, or math for my blog posts, but the native support for divs and the ability to add attributes to any element is something I've really been missing.

# Tools

Given that Djot is a relatively young project, I expected the tooling to be lacking.
There are things missing, but it wasn't so bad for my use-case.

I found a Djot Sublime Text grammar I can use for syntax highlighting the blog,
and there is Vim syntax highlighting in the [Djot repo][Djot].

(Sad for those who don't use Vim I guess.)

More annoying is that there's no treesitter implementation for Djot.
This is unfortunate, as with treesitter I get proper syntax highlighting inside code blocks for Markdown and I have a general treesitter jump command that, for Markdown, jumps between headers with `]g` and `[g`.
(In Rust it jumps between structs, implementations, enums, and functions.)

Not a deal-breaker of course.
Using the Markdown treesitter works well enough for the time being.
(Maybe I need to explore how treesitter grammars work one day, and create one for Djot.)

As for parsing I found [Jotdown][], which is a Rust library with an API inspired by [pulldown-cmark][], the library I use to parse CommonMark.

# Abstracting away markup parsing

I didn't want to convert my existing Markdown files as I have more than 250 posts. (Yes, that's mad.)

So to add Djot support I had to refactor my site generator a bit and support both Djot and Markdown parsing.
I've been lazy so this wasn't as straightforward as I hoped; I had sprinkled calls to Markdown parsing all over the place.

When I don't really know where to begin unwinding such a mess, I like to begin by modeling the data types in the domain.
If I get them right, the rest usually falls into place fairly quickly.

One of the things I love about Rust is the enums (or sum types for you fancy people) which makes it easy to model an "either this or that" type:

```rust
#[derive(Debug, Copy, Clone)]
pub enum MarkupType {
    Markdown,
    Djot,
}
```

You can also add data to each variant, like so:

```rust
#[derive(Debug, Clone)]
pub enum Markup {
    Markdown(String),
    Djot(String),
}
```

This is nice because now the type system prevents you from accidentally using the wrong format, which would be easier if you stored a `MarkupType` and a `String` separately.

I did indeed do this:

```rust
pub struct PostItem {
  // Is this in markdown or already parsed to html?
  // Wait, maybe it's in djot!
  pub content: String,
}
```

To prevent this we we should probably create a newtype for html as well:

```rust
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Html(pub String);
```

Then to parse the markup you can add a `parse` method to `Markup`, that delegates to the right parser:

```rust
impl Markup {
    pub fn parse(&self) -> Result<Html> {
        match self {
            Self::Markdown(s) => markdown_to_html(&s),
            Self::Djot(s) => djot_to_html(&s),
        }
    }
}
```

Now posts can hold `Markup` and `Html` structs and not having to worry about losing track of what content they represent:

```rust
pub struct PostItem {
    pub content: Html,
    pub markup: Markup,
    // Many other fields omitted..
}
```

With the right types in place the rest of the refactoring falls into place automatically.
Just hide any Markdown and Djot specific implementation behind these types, follow the compile errors, and you're soon done.
Thinking and designing with types is usually a pleasure.

# Customized markup

For the blog I have some [markup transformations][] I apply to Markdown.
This includes demoting headers (they only `h1` i want is the post title), embedding bare YouTube links and prettifying code markup.

It's a bit hacky though.

## Epigraphs

For example, I want to be able to turn a quote into an epigraph by wrapping it inside a div:

```html
<div class="epigraph">
  <blockquote>
    <p>This is an epigraph</p>
  </blockquote>
</div>
```

But the CommonMark parser doesn't process markdown inside html, so I [added an attribute parser][extending-pulldown_cmark] to wrap a quote in an epigraph:

```markdown
> This is an epigraph
{ :epigraph }
```

The implementation isn't pretty, and only works for specific elements such as a blockquote.
But Djot has a built-in syntax for divs, so I can just write this to produce the same epigraph html output:

```djot
::: epigraph
> This is an epigraph
:::
```

## Asides

I still need to do a bunch of transformations to reproduce existing functionality.

For instance, I want html output like this:

```html
<aside>
  <p>This is a notice</p>
</aside>
```

There isn't a native way to do this (other than inserting raw html, _ew_).
For my own transformations the `div` system works well as a starting point, so I can use this kind of input:

```djot
::: notice
This is a notice
:::
```

And then match on the `notice` class to transform the `div` into `aside`.

In [Jotdown][], like with [pulldown-cmark][], transformations are made by transforming iterators over events (in this case I'm looking for `Event::Start(Container::Div, attrs)` and `Event::End(Container::Div)`).
It's a bit awkward, so keeping the transformations small is nice.

## Images

I used the same syntax in Markdown to create collections of images:

```markdown
::: Flex
/images/configura14/octree1.png{ height=300 }
/images/configura14/octree2.png{ height=300 }
:::
```

This would wrap the images in a flex container to display them side-by-side:

::: flex
![](/images/configura14/octree1.png){ height=300 }
![](/images/configura14/octree2.png){ height=300 }
:::

```html
<figure class="flex-50">
  <a href="/images/configura14/octree1.png"><img height="300" alt="" src="/images/configura14/octree1.png"></a>
  <a href="/images/configura14/octree2.png"><img height="300" alt="" src="/images/configura14/octree2.png"></a>
</figure>
```

I (naturally) used to do this with Regex in a preprocessor step,
and had some fun adding attribute parsing.

Now all I do is transform the `div` to a `figure` with the proper class.
Even something like this with references outside and attributes works now, without any special handling on my end:

```djot
::: flex
![][one]{ height=300 }
![][two]{ height=300 }
:::

[one]: /images/configura14/octree1.png
[two]: /images/configura14/octree2.png
```

(Yeah maybe I gloss over the gross implementation a little.)

## Other transformations

There are other transformations I do with Djot as well:

```rust
pub fn djot_to_html(djot: &str) -> Result<String> {
    let transformed = Parser::new(djot);
    // Demote headers (eg h1 -> h2) and give them an "a" tag.
    let transformed = TransformHeaders::new(transformed);
    // Convert standalone images to figures.
    let transformed = AutoFigures::new(transformed);
    // Embed raw youtube links using iframes.
    let transformed = EmbedYoutube::new(transformed);
    // Syntax highlighting.
    let transformed = CodeBlockSyntaxHighlight::new(transformed);
    let transformed = InlineCodeSyntaxHighlight::new(transformed);
    // Transform divs, such as asides and figures.
    let transformed = DivTransforms::new(transformed);
    // Add a <footer> with author info to quotes.
    let transformed = QuoteTransforms::new(transformed);

    let mut body = String::new();
    Renderer::default().push(transformed, &mut body)?;
    Ok(body)
}
```

The ones I didn't bring up in the blog are pretty similar to their Markdown implementation.
I'm not going to go through them in detail, see the source code if you're interested.

[CommonMark]: https://commonmark.org/
[Pandoc]: https://pandoc.org/
[Beyond Markdown]: https://johnmacfarlane.net/beyond-markdown.html
[Djot]: https://github.com/jgm/djot
[pulldown-cmark]: https://crates.io/crates/pulldown-cmark
[Jotdown]: https://github.com/hellux/jotdown
[markup transformations]: /blog/2022/08/29/rewriting_my_blog_in_rust_for_fun_and_profit/#markdown-transformations
[extending-pulldown_cmark]: /blog/2022/08/29/rewriting_my_blog_in_rust_for_fun_and_profit/#extending-pulldown_cmark
