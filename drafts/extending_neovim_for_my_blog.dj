---toml
title = "Extending Neovim for my blog"
tags = ["Lua",  "Rust",  "Webpage"]
---

I've been using Neovim since it forked from Vim almost 8 years ago, and I used Vim many years before that.
I feel quite comfortable with Neovim, and I've gone down the [configuration rabbit hole][] too many times I'd like to admit, but I never dived deeper by writing something truly custom like a plugin.

That changed when I got inspired by the excellent [Developing a Neovim Docker Plugin from Scratch][] where the creator goes through how to extend [telescope.nvim][] in a very pedagogical manner.

I ended up extending Neovim and my blog backend with some sorely needed features such as:

1. Browse posts using [telescope.nvim][].
1. Autocomplete post urls, link definitions, and more using [nvim-cmp][].
1. Goto definition.
1. Diagnostics.
1. Browser preview with auto refresh and scroll.

This post will go through how I implemented the above features.
The focus will be on Neovim and Lua side of things, but I'll call out some backend Rust details too.

# Initial setup

While I could develop this as a normal plugin, because it's so coupled to my setup I decided to organize it under `nvim/lua/blog` and simply include it in my init script:

```lua
require("blog")
```

This calls `nvim/lua/blog/init.lua` that in turn requires other initialization files:

```lua
require("blog.autocmd")
require("blog.cmp")
require("blog.commands")
```

Another quirk of my [Neovim config][] is that I've tried to collect all keymaps in one file, where I added some new keymaps for the blog:

```lua
local map = vim.keymap.set

M.init = function()
  map("n", "gd", require("blog.telescope").find_draft, { desc = "Find blog draft" })
  map("n", "gp", require("blog.telescope").find_post, { desc = "Find blog post" })
  -- Lots of other things...
end

M.buf_blog = function(buffer)
  map("n", "<localleader>t", require("blog.telescope").find_tags, { buffer = buffer, desc = "List tags" })
  map("i", "<C-t>", require("blog.telescope").find_tags, { buffer = buffer, desc = "List tags" })
  map("n", "<localleader>d", require("blog.interaction").goto_def, { buffer = buffer, desc = "Goto definition" })
end
```

Where `buf_blog` is called by an autocommand when editing a blog post.

That's it for hooking up the code into my Neovim setup, now let's look at what the code does.

# Creating and moving posts

Let's start by moving some functionality from the blog generation backend to Neovim:

- Creating a draft with a small template.
- Promote a draft to a blog post and demote a post back to a draft.

I don't really know why I had these implemented as commands line arguments to the backend---they fit much better in Neovim.

They're implemented as user commands:

```lua
local cmd = require("util").create_cmd
local files = require("blog.files")

-- Create a new draft, promote it to a post, or revert it back to a draft.
cmd("BlogNewDraft", files.new_draft)
cmd("BlogPromoteDraft", files.promote_curr_draft)
cmd("BlogDemotePost", files.demote_curr_post)
```

Where `create_cmd` is a small helper snippet I stole from somewhere:

```lua
M.create_cmd = function(command, f, opts)
  opts = opts or {}
  vim.api.nvim_create_user_command(command, f, opts)
end
```

## New draft

Creating a draft should do two simple things:

1. Create a file at `drafts/some_title.dj` under the blog directory.
2. Open it and fill in some placeholder data.

Creating a file can be done using `vim.cmd` to send the `:edit` command.

Inserting text from lua was harder, I tried to search for help with `:Telescope help_tags` but came up short.
In the end I found `vim.api.nvim_buf_set_lines` via Google that can be used to insert lines.

This is the solution I came up with:

```lua
local path = require("blog.path")
local nio = require("nio")

-- A module file in lua by convention use an `M` table,
-- allowing us to call `require("blog.files").new_draft()`.
local M = {}

M.new_draft = function()
  nio.run(function()
    -- Prompt for the title of the new draft.
    local title = nio.ui.input({ prompt = "Draft title: " })

    -- Create and open the draft for edit (without checking if it exists...)
    -- `path.blog_path` expands to the path to my blog and `slugify` converts
    -- a title to a slug by replacing spaces with underscores and removing symbols.
    local file_path = path.blog_path .. "drafts/" .. M.slugify(title) .. ".dj"
    vim.cmd(":e " .. file_path)

    -- The text the draft will start with.
    local template = {
      "---toml",
      'title = "' .. title .. '"',
      'tags = ["Some tag"]',
      "---",
    }
    -- Insert the text into the current buffer at row 0 (to 0).
    local buf = vim.api.nvim_get_current_buf()
    vim.api.nvim_buf_set_lines(buf, 0, 0, true, template)
  end)
end

return M
```

I hope it's clear what the above code is doing, but I want to call out the usage of [nvim-nio][].
It's a great library that makes asynchronous programming simple in Neovim.

To start an async task you use `nio.run`:

```lua
nio.run(function()
  -- Code here is run async
end)
```

For this example of creating a new draft async is overkill.
Async is required for some other situations and it's easy to add so I use it liberally, even when not strictly needed.

## Moving files

In my blogging setup I store posts under `posts/` with the release date in the path, and drafts under `drafts/`.
So promoting and demoting is accomplished by moving the file:

- Promote a draft to a post by moving it from `drafts/post_title.dj` to `posts/2024-04-14-post_title.dj`.
- Demote a post by moving it from `posts/2024-04-14-post_title.dj` to `drafts/post_title.dj`.

I'm not going to include all the code here, but here are the most important implementation details:

1. Extract the title from the post by shelling out to [ripgrep][].

   [nvim-nio][] provides `process.run` to run a shell command:

   ```lua
   local proc = nio.process.run(args)
   proc.stdout.read()
   ```

   That we can run [ripgrep][] to search for the title:

   ```lua
   {
     cmd = "rg",
     args = {
       "-NoH",
       "^title = (.+)",
       path,
     },
   }
   ```

   ::: notice
   Another solution would be to rely on the backend to provide the title.
   It would be more robust since the backend properly parses the file,
   but when I first created this function I didn't have the backend connection.
   :::

1. Create the destination path.

   When promoting a draft for example:

   ```lua
   path.blog_path .. "posts/" .. os.date("%Y-%m-%d") .. "-" .. M.slugify(title) .. ".dj"
   ```

1. Move the file.

   I don't know what the idiomatic way to rename a file is, or even how to do it in Neovim.
   But I do know that with `:!` you can call an external program... Like `mv`!

   So here's an ugly way to rename the current file:

   ```lua
   vim.cmd(":!mv " .. from .. " " .. to)
   vim.cmd(":e " .. to)
   ```

   Because everything is done in an async context (inside `nio.run`) we run into a problem: we can't call the Neovim API without yielding to the Neovim scheduler.

   What we need to do is call `scheduler` before we rename the file:

   ```lua
   nio.scheduler()
   -- Now we can call `vim.cmd` and `vim.fn`.
   ```

# Browse posts with [telescope.nvim][]

I've used [telescope.nvim][]\'s find files with `require("telescope.builtin").find_files`lua for quite some time.
I use find files together with it's cousin `.oldfiles` (find recently opened files) all the time for finding source code files, blog posts, and more.

But it's naturally restricted to operate on only filenames and you can make telescope richer by operating on structured data.

So let's move away from using the files finder to find posts:

![](/images/find_files.png)

To a custom posts picker that display posts in a neater way and allows us to filter using tags or other metadata:

![](/images/find_posts.png)

## The simplest picker

It's fairly easy to create a new picker for [telescope.nvim][].
In it's simplest form, all you need to do is provide a list of items to `telescope.pickers`:

```lua
local pickers = require("telescope.pickers")
local finders = require("telescope.finders")

pickers
  .new(opts, {
    finder = finders.new_table({
      results = { "One", "Two", "Three" },
    }),
  })
  :find()
```

::: notice
How do I know this?
Because I watched [Developing a Neovim Docker Plugin from Scratch][].
It does a way better job walking you through a telescope plugin than I could ever do.
:::

## Structured content

To make our simple picker handle structured content we need to:

1. Convert `results` to a list of tables with the info we have.
1. Specify an `entry_marker` function.

It essentially looks like this:

```lua
finder = finders.new_table({
  -- 1. Structured data inside `results`.
  results = {
    { title = "One", tags = "Tag1, Tag2", path = "posts/2024-01-01-one.dj" },
    { title = "Two", tags = "Tag2", path = "posts/2024-02-02-two.dj" },
  },
  -- 2. A function that converts a result entry to an entry telescope understands.
  entry_maker = function(entry)
    return {
      -- Display the post title instead of the path in the list.
      display = entry.title,
      -- Allow us to filter against the title and tags (typing `Tag1` finds the "One" post).
      ordinal = entry.title .. entry.tags,
      -- Save the whole entry for future usage.
      value = entry,
    }
  end,
}),
```

With this the finder displays the title of the post rather than the file path, and we can search for a post using the title and its tags.
In my post picker I also display the date and allow you to filter by [series](/series) id.

I tried to have the path in the ordinal as well, but because of the fuzzy matching the path cluttered the search result by including way too many posts.

## File preview

One of the great features of [telescope.nvim][] is the very fast preview with syntax highlighting, which we of course must configure.

I searched through the telescope help, and found the functions `new_buffer_previewer` and `buffer_previewer_maker` that allows us to define a previewer for a file:

```lua
local previewers = require("telescope.previewers")

finder = finders.new_table({
  -- ...

  previewer = previewers.new_buffer_previewer({
    -- Title isn't needed.
    title = "Post Preview",
    define_preview = function(self, entry)
      -- Notice `entry.value.path` that uses our catch-all entry value.
      conf.buffer_previewer_maker(entry.value.path, self.state.bufnr, {
        bufname = self.state.bufname,
        winid = self.state.winid,
        preview = opts.preview,
        -- The file encoding is needed for proper syntax highlighting.
        file_encoding = opts.file_encoding,
      })
    end,
  }),
})
```

I'm not sure if there's a less verbose way to define a file previewer, as the only thing I really configured here is the title and the `entry.value.path` argument to `buffer_preview_maker`.

## Open the selected file

We already have configured the display of our [telescope.nvim][] picker configured.
The only question left is how do we open the file once we've found it?

The answer is yet another argument to `finders.new_table` called `attach_mappings`:

```lua
local actions = require("telescope.actions")

finder = finders.new_table({
  -- ...
  attach_mappings = function(prompt_bufnr)
    actions.select_default:replace(function()
      local selection = action_state.get_selected_entry()
      actions.close(prompt_bufnr)
      vim.cmd(":e " .. selection.value.path)
    end)
    return true
  end,
})
```

The above mapping overrides the default selection action (`<CR>` in my case) to `:edit` `value.path` of our selection, which will open the selected file.

Multiselection is possible in telescope, which you need to handle in the mapping function if you want to support it.

## Finding the post data to populate the picker

So far I've only used placeholder data for the posts, but of course I need to search the file system for the markup files for the posts.

How did I extract the post metadata, which is defined inside the posts in a frontmatter?
This is a frontmatter that's defined at the start of every markup file:

```
---toml
title = "Let's build a VORON: Noise"
tags = ["3D printing", "VORON"]
series = "voron_trident"
---
```

With [ripgrep][] and regex of course!

This time though I have a good reason for choosing an external tool rather than asking the backend server:
I want to be able to find a post the very first thing I do when opening Neovim, and I don't want to wait on connecting to a backend service, or requiring one running at all times.

The strategy is to use [ripgrep][] to match the frontmatter in all posts, extract the metadata using some hacky Lua regex, and combine them into a post struct we can feed into the [finder we developed](#Structured-content).

This is one way to find all posts under a path and extract the frontmatter using [ripgrep][]\'s regex syntax:

```lua
nio.process.run({
  cmd = "rg",
  args = {
    "-NoHU",
    "--heading",
    "^\\---\\w*\\n(.+\\n)+^---",
    -- subpath could be `posts/` or `drafts/`, using absolute paths
    path.blog_path .. subpath,
  },
})
```

Which will produce output formatted like this:

```
posts/2016-07-29-slackware_installation_notes.markdown
---
layout: post
title: "Slackware installation notes"
tags: Slackware
---

posts/2019-01-25-site_restyle_and_update.markdown
---
title: "Site restyle and update"
tags: ["Webpage", "Web Design"]
---
```

My code for splitting the output and extracting the metadata is a little gross, but I don't know how to make it prettier:

```lua
local lines = vim.fn.split(output, "\n")
local posts = {}

local post = {}
-- You iterate over lists in lua with `ipairs`.
for _, line in ipairs(lines) do
  -- When a newline is encountered save the post and prepare for the next entry.
  if line == "" then
    if post.title then
      table.insert(posts, post)
    end
    post = {}
  -- Skip `---` markers.
  elseif not string.match(line, "%-%-%-%w*") then
    -- Try to extract all key value definitions and store them.
    local key, value = string.match(line, '(%w+)%s*[:=]%s*"?(.+)"?')
    if key then
      post[key] = value
    else
      -- If no key value pair is found, then we should be at the beginning with the file path.
      post["path"] = line
      -- Only posts have a date in the path, not drafts.
      local date = string.match(line, "posts/(%d%d%d%d%-%d%d%-%d%d)%-")
      if date then
        post["date"] = date
      end
    end
  end
end
-- If output ends we might have an unsaved post.
if post.title then
  table.insert(posts, post)
end
```

Yes, I'm using regex to parse `yaml`/`toml` values.

I could try to find a lua parser, but this is fine...

![](/images/regex_this_is_fine.jpg)

It does mean we have a working [telescope.nvim][] picker!
I may have skipped some details, so [take a look at the source code](https://github.com/treeman/dotfiles/blob/master/.config/nvim/lua/blog/telescope.lua) if you're interested.

# Communicating with the backend process

I've referred to "the backend" a bunch, but what is it and why do we need one?

First thing to keep in mind is that my blog is a static site.
There's no backend that serves content, it's just files that I serve directly from Amazon S3.
To create these files I have a [static site generator][blog_code] (command line program) that converts markup files to HTML files.
There's no need for a backend here.

Except that the writing experience isn't so great if you always have to regenerate the site using the command line and search for the output file in your file system if you just want to view the site in the browser.

I therefore have a small web server using [axum][] built into the site generator.
It's used to serve the site at `localhost:8080` and uses [hotwatch][] to automatically rebuild the site when I write.
This is what I've been calling "the backend", even though it's only used locally.

If we could open a connection and make Neovim communicate with the backend, we could do cool things like autocomplete any site url (which is very different from autocompleting file paths), or jump to link definitions (there's no LSP for Djot yet).

## Channels

## TCP from Rust

# Autocompletion with [nvim-cmp][]

# Goto definition

# Diagnostics

# Connction status with lualine

# Browser preview

## Websocket communication

- flume multiple producer and consumer

## Scrolling


[nvim-cmp]: https://github.com/hrsh7th/nvim-cmp
[telescope.nvim]: https://github.com/nvim-telescope/telescope.nvim
[configuration rabbit hole]: /blog/2023/10/01/rewriting_my_neovim_config_in_lua
[Developing a Neovim Docker Plugin from Scratch]: https://www.youtube.com/watch?v=HXABdG3xJW4
[Neovim config]: /blog/2023/10/01/rewriting_my_neovim_config_in_lua
[nvim-nio]: https://github.com/nvim-neotest/nvim-nio
[ripgrep]: https://github.com/BurntSushi/ripgrep
[blog_code]: https://github.com/treeman/jonashietala
[hotwatch]: https://github.com/francesca64/hotwatch
[axum]: https://github.com/tokio-rs/axum
