---toml
title = "Browse posts with telescope.nvim"
tags = ["Lua",  "Rust",  "Webpage"]
series = "extending_neovim_for_my_blog"
---

I've used [telescope.nvim][]\'s find files with `require("telescope.builtin").find_files`lua for quite some time.
I use find files together with it's cousin `.oldfiles` (find recently opened files) all the time for finding source code files, blog posts, and more.

But it's naturally restricted to operate on only filenames and you can make telescope richer by operating on structured data.

So let's move away from using the files finder to find posts:

![](/images/extend_blog/find_files.png)

To a custom posts picker that display posts in a neater way and allows us to filter using tags or other metadata:

![](/images/extend_blog/find_posts.png)

## The simplest picker

It's fairly easy to create a new picker for [telescope.nvim][].
In it's simplest form, all you need to do is provide a list of items to `telescope.pickers`:

```lua
local pickers = require("telescope.pickers")
local finders = require("telescope.finders")

pickers
  .new(opts, {
    finder = finders.new_table({
      results = { "One", "Two", "Three" },
    }),
  })
  :find()
```

::: notice
How do I know this?
Because I watched [Developing a Neovim Docker Plugin from Scratch][].
It does a way better job walking you through a telescope plugin than I could ever do.
:::

All you then need to do is make sure to call the above code somehow, for example by wrapping it in a function and add a keymap to it:

```lua
local map = vim.keymap.set
map("n", "gd", require("blog.telescope").find_draft, { desc = "Find blog draft" })
map("n", "gp", require("blog.telescope").find_post, { desc = "Find blog post" })
```

## Structured content

To make our simple picker handle structured content we need to:

1. Convert `results` to a list of tables with the info we have.
1. Specify an `entry_marker` function.

A rewrite of `finder` in our simple picker might look like this:

```lua
finder = finders.new_table({
  -- 1. Structured data inside `results`.
  results = {
    { title = "One", tags = "Tag1, Tag2", path = "posts/2024-01-01-one.dj" },
    { title = "Two", tags = "Tag2", path = "posts/2024-02-02-two.dj" },
  },
  -- 2. A function that converts a result entry to an entry telescope understands.
  entry_maker = function(entry)
    return {
      -- Display the post title instead of the path in the list.
      display = entry.title,
      -- Allow us to filter against the title and tags (typing `Tag1` finds the "One" post).
      ordinal = entry.title .. entry.tags,
      -- Save the whole entry for future usage.
      value = entry,
    }
  end,
}),
```

With this the finder displays the title of the post rather than the file path, and we can search for a post using the title and its tags.

It's easy to add more metadata to `ordinal` and it'll mostly work, but the matching is crude and it can easily misfire depending on your use-case.

Because the way fuzzy matching works, if I type *lua* with the hope of listing all posts tagged lua, it will also match any post that has the letters *l* *u* *a* in that order, which is currently almost 40 of them:

![Prompting for `lua` matches too many posts.](/images/extend_blog/lua_match_voron.png)

Clearly, there's room for improvement.

## Structured filtering and sorting

Turns out that `ordinal` can also be a table, and you can provide your own `sorter` that operates on the ordinal to sort and filter.

This is the basic setup, where we'll later fill in `scoring_function`:

```lua
finder = finders.new_table({
  results = {
    -- `tags` is now a list.
    { title = "One", tags = { "Tag1", "Tag2" }, path = "posts/2024-01-01-one.dj" },
    { title = "Two", tags = { "Tag2" }, path = "posts/2024-02-02-two.dj" },
  },
  entry_maker = function(entry)
    return {
      display = entry.title,
      -- `ordinal` is now a table.
      ordinal = {
        title = entry.title,
        tags = entry.tags,
      },
      value = entry,
    }
  end,
  -- We need to specify a `sorter`.
  sorter = function(opts)
    -- A sorter is created using `Sorter.new`.
    return require("telescope.sorters").Sorter:new({
      -- We want to filter, so we'll set `discard` to true.
      discard = true,

      -- This function should compare the prompt string the user inputs
      -- against the ordinal entry created by the `entry_maker`.
      scoring_function = function(_, prompt, ordinal)
        return 0
      end,
    })
  end,
}),
```

There's some ceremony here that I hope is clear enough.
The important thing here is the `scoring_function` that we'll need to implement.

First, the input arguments:

1. The first argument seems to be ignored even in Telescope's own sorters, so I ignore it as well.

1. `prompt` is the user input to the Telescope prompt as a string.

1. `ordinal` is the ordinal entry that `entry_maker` returns.

  For example:

  ```lua
  { title = "Two", tags = { "Tag2" } }
  ```

What `scoring_function` should do is return a single numeric value signifying how close `ordinal` is to `prompt`, where higher means a better match.
Because we defined `discard = true`lua if we return a value less than `0`lua, the entry will get removed (filtered).

At first I thought this was a weird way of creating a sorting function.
I had expected a comparison function like `cmp(left, right)`lua, but after having implemented structured sorting for posts it feels pretty clever.

### Sorter requirements

Before jumping into implementation details, let's take a step back and figure out what behavior we want.
You could go nuts with advanced features such as boolean operators, set comparisons, and similar.
While cool, I don't think it's worth implementing as my requirements are fairly simple:

- Fuzzy find on title, tags, and series.

  I don't want to require a perfect match on tags, requiring me to fully type out for example [Experimental Gameplay Project][] would be _quite_ annoying.

- Explicitly filter posts by series and tags.

  It's neat if you can type some text and it filters for series _or_ post title, but in practice I never really want that.
  If I want to filter against the post series, I want to be explicit about it and the same holds for tags.

  (I tried the implicit way; it didn't feel right.)

- Filter posts containing `tag1` _and_ `tag2`.

  I contemplated searching for `tag1` _or_ `tag2`, but what I want is to reduce the number of matches as I add more information, not increase them.

- Include published date in ordering.

  At a base level I want to see newer posts before older ones.
  This is especially true when I first open telescope without a prompt, then I want to see an ordered lists of all posts.

### Prompt syntax

Because I want to be explicit we need some syntax to separate text we want to match against post tags, series, and title.
Simplicity is nice, and a simple solution is to treat `@` prefixed words as tag matches and `#` prefixed words as series matches.
I always find that an example is worth a 1000 words, so here are some examples to shave down the precious words count:

i. `@rust gleam`

   Require a post tag matching `rust` and post title matching `gleam`.

i. `@3d @hex`

   Require a post tag matching `3d` and one matching `hex`.

i. `#34`

   Require a post series matching `34`.

i. `build # start`

   Require a post with a series and post title matching `build start`.

The code that splits a prompt into parts is conceptually simple: split the prompt into words and categorize them depending starting character.
This is what I use:

```lua
local function split_prompt(prompt)
  local tags = {}
  local series = {}
  local title = {}
  -- Iterates over all non-space substrings.
  -- `prompt:gmatch` is syntax sugar for `string.gmatch(prompt, ..)`
  for word in prompt:gmatch("([^%s]+)") do
    -- `sub(1, 1)` works with empty strings too!
    local fst = word:sub(1, 1)
    if fst == "@" then
      -- Don't include the `@` in tags.
      table.insert(tags, word:sub(2))
    elseif fst == "#" then
      table.insert(series, word:sub(2))
    else
      table.insert(title, word)
    end
  end

  return {
    tags = tags,
    series = series,
    -- Combine non-tagged elements into a string.
    -- Could've be done outside this function but it'll always be done
    -- so I thought it would be easier to join here.
    title = vim.fn.join(title, " "),
  }
end
```

I'm a bit of a Lua noob, so there may be other ways to do solve this.

### Implementing `scoring_function`

## File preview

One of the great features of [telescope.nvim][] is the very fast preview with syntax highlighting, which we of course must configure.

I searched through the telescope help, and found the functions `new_buffer_previewer` and `buffer_previewer_maker` that allows us to define a previewer for a file:

```lua
local previewers = require("telescope.previewers")

finder = finders.new_table({
  -- ...

  previewer = previewers.new_buffer_previewer({
    -- Title isn't needed.
    title = "Post Preview",
    define_preview = function(self, entry)
      -- Notice `entry.value.path` that uses our catch-all entry value.
      conf.buffer_previewer_maker(entry.value.path, self.state.bufnr, {
        bufname = self.state.bufname,
        winid = self.state.winid,
        preview = opts.preview,
        -- The file encoding is needed for proper syntax highlighting.
        file_encoding = opts.file_encoding,
      })
    end,
  }),
})
```

I'm not sure if there's a less verbose way to define a file previewer, as the only thing I really configured here is the title and the `entry.value.path` argument to `buffer_preview_maker`.

## Open the selected file

We already have configured the display of our [telescope.nvim][] picker configured.
The only question left is how do we open the file once we've found it?

The answer is yet another argument to `finders.new_table` called `attach_mappings`:

```lua
local actions = require("telescope.actions")

finder = finders.new_table({
  -- ...
  attach_mappings = function(prompt_bufnr)
    actions.select_default:replace(function()
      local selection = action_state.get_selected_entry()
      actions.close(prompt_bufnr)
      vim.cmd(":e " .. selection.value.path)
    end)
    return true
  end,
})
```

The above mapping overrides the default selection action (`<CR>` in my case) to `:edit` `value.path` of our selection, which will open the selected file.

Multiselection is possible in telescope, which you need to handle in the mapping function if you want to support it.

## Finding the post data to populate the picker

So far I've only used placeholder data for the posts, but of course I need to search the file system for the markup files for the posts.

How did I extract the post metadata, which is defined inside the posts in a frontmatter?
This is a frontmatter that's defined at the start of every markup file:

```
---toml
title = "Let's build a VORON: Noise"
tags = ["3D printing", "VORON"]
series = "voron_trident"
---
```

With [ripgrep][] and regex of course!

This time though I have a good reason for choosing an external tool rather than asking the backend server:
I want to be able to find a post the very first thing I do when opening Neovim, and I don't want to wait on connecting to a backend service, or requiring one running at all times.

The strategy is to use [ripgrep][] to match the frontmatter in all posts, extract the metadata using some hacky Lua regex, and combine them into a post struct we can feed into the [finder we developed](#Structured-content).

This is one way to find all posts under a path and extract the frontmatter using [ripgrep][]\'s regex syntax:

```lua
nio.process.run({
  cmd = "rg",
  args = {
    "-NoHU",
    "--heading",
    "\\A\\---\\w*\\n(.+\\n)+^---",
    -- subpath could be `posts/` or `drafts/`, using absolute paths
    path.blog_path .. subpath,
  },
})
```

Which will produce output formatted like this:

```
posts/2016-07-29-slackware_installation_notes.markdown
---
layout: post
title: "Slackware installation notes"
tags: Slackware
---

posts/2019-01-25-site_restyle_and_update.markdown
---
title: "Site restyle and update"
tags: ["Webpage", "Web Design"]
---
```

My code for splitting the output and extracting the metadata is a little gross, but I don't know how to make it prettier:

```lua
local lines = vim.fn.split(output, "\n")
local posts = {}

local post = {}
for _, line in ipairs(lines) do
  -- When a newline is encountered save the post and prepare for the next entry.
  if line == "" then
    if post.title then
      table.insert(posts, post)
    end
    post = {}
  -- Skip `---` markers.
  elseif not string.match(line, "%-%-%-%w*") then
    -- Try to extract all key value definitions and store them.
    local key, value = string.match(line, "(%w+)%s*[:=]%s*(.+)")
    if key then
      -- Strip surrounding quotes.
      -- Do this here because there's no non-greedy specifier that could be used
      -- in the key/value regex above.
      local stripped = string.match(value, '^"(.+)"$')
      if stripped then
        value = stripped
      end
      post[key] = value
    else
      -- If no key value pair is found, then we should be at the beginning with the file path.
      post["path"] = line
      -- Only posts have a date in the path, not drafts.
      local date = string.match(line, "posts/(%d%d%d%d%-%d%d%-%d%d)%-")
      if date then
        post["date"] = date
      end
    end
  end
end
-- If output ends we might have an unsaved post.
if post.title then
  table.insert(posts, post)
end
```

Yes, I'm using regex to parse `yaml`/`toml` values.

I could try to find a lua parser, but eeeh...

![](/images/extend_blog/regex_this_is_fine.jpg)

It does mean we have a working [telescope.nvim][] picker!
I may have skipped some details, so [take a look at the source code](https://github.com/treeman/dotfiles/blob/master/.config/nvim/lua/blog/telescope.lua) if you're interested.

[telescope.nvim]: https://github.com/nvim-telescope/telescope.nvim
[ripgrep]: https://github.com/BurntSushi/ripgrep
[Developing a Neovim Docker Plugin from Scratch]: https://www.youtube.com/watch?v=HXABdG3xJW4
[Experimental Gameplay Project]: /blog/tags/experimental_gameplay_project
